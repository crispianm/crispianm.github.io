<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MusicalBuildings</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<div id="map"></div>

<script>
	mapboxgl.accessToken = 'pk.eyJ1IjoiY3Jpc3BpYW5tIiwiYSI6ImNsMG1oazJhejE0YzAzZHVvd2Z1Zjlhb2YifQ.cv0zlPYY6WnoKM9YLD1lMQ';
    // Use a minimal variant of the Mapbox Dark style, with certain features removed.
    const map = new mapboxgl.Map({
        style: 'mapbox://styles/mapbox/cjaudgl840gn32rnrepcb9b9g',
        center: {
            lng: -2.6192,
            lat: 51.4493
        },
        zoom: 15,
        pitch: 55,
        container: 'map',
        antialias: true
    });

    map.addControl(new mapboxgl.FullscreenControl());

    map.addControl(
        new mapboxgl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true
            },
            // When active the map will receive updates to the device's location as it changes.
            trackUserLocation: true,
            // Draw an arrow next to the location dot to indicate which direction the device is heading.
            showUserHeading: true
        })
    );

    map.on('load', () => {

        map.addSource(
            'mapbox-dem', {
                'type': 'raster-dem',
                'url': 'mapbox://mapbox.terrain-rgb',
                'tileSize': 512,
                'maxzoom': 14
            });
        // add the DEM source as a terrain layer with exaggerated height
        map.setTerrain({
            'source': 'mapbox-dem',
            'exaggeration': 1.5});
        
        // add a sky layer that will show when the map is highly pitched
        map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
                'sky-type': 'atmosphere',
                'sky-atmosphere-sun': [0.0, 0.0],
                'sky-atmosphere-sun-intensity': 15
            }
        });

        map.addLayer({
            'id': 'hillshading',
            'source': 'mapbox-dem',
            'type': 'hillshade'
            // insert below waterway-river-canal-shadow;
            // where hillshading sits in the Mapbox Outdoors style
            },
            'waterway-river-canal-shadow'
        );

        const bins = 16;
        const maxHeight = 50;
        const binWidth = maxHeight / bins;

        // Divide the buildings into 16 bins based on their true height, using a layer filter.
        for (let i = 0; i < bins; i++) {
            map.addLayer({
                'id': `3d-buildings-${i}`,
                'source': 'composite',
                'source-layer': 'building',
                'filter': [
                    'all',
                    ['==', 'extrude', 'true'],
                    ['>', 'height', i * binWidth],
                    ['<=', 'height', (i + 1) * binWidth]
                ],
                'type': 'fill-extrusion',
                'minzoom': 14,
                'paint': {
                    'fill-extrusion-color': '#aaa',
                    'fill-extrusion-height-transition': {
                        duration: 0,
                        delay: 0
                    },
                    'fill-extrusion-opacity': 1
                }
            });
        }

        // Older browsers might not implement mediaDevices at all, so we set an empty object first
        if (navigator.mediaDevices === undefined) {
            navigator.mediaDevices = {};
        }

        // Some browsers partially implement mediaDevices. We can't just assign an object
        // with getUserMedia as it would overwrite existing properties.
        // Here, we will just add the getUserMedia property if it's missing.
        if (navigator.mediaDevices.getUserMedia === undefined) {
            navigator.mediaDevices.getUserMedia = (constraints) => {
                // First get ahold of the legacy getUserMedia, if present
                const getUserMedia =
                    navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

                // Some browsers just don't implement it - return a rejected promise with an error
                // to keep a consistent interface
                if (!getUserMedia) {
                    return Promise.reject(
                        new Error(
                            'getUserMedia is not implemented in this browser'
                        )
                    );
                }

                // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
                return new Promise((resolve, reject) => {
                    getUserMedia.call(navigator, constraints, resolve, reject);
                });
            };
        }

        navigator.mediaDevices
            .getUserMedia({ audio: true })
            .then((stream) => {
                // Set up a Web Audio AudioContext and AnalyzerNode, configured to return the
                // same number of bins of audio frequency data.
                const audioCtx = new (window.AudioContext ||
                    window.webkitAudioContext)();

                const analyser = audioCtx.createAnalyser();
                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;
                analyser.smoothingTimeConstant = 0.85;

                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);

                analyser.fftSize = bins * 2;

                const dataArray = new Uint8Array(bins);

                function draw(now) {
                    analyser.getByteFrequencyData(dataArray);

                    // Use that data to drive updates to the fill-extrusion-height property.
                    let avg = 0;
                    for (let i = 0; i < bins; i++) {
                        avg += dataArray[i];
                        map.setPaintProperty(
                            `3d-buildings-${i}`,
                            'fill-extrusion-height',
                            10 + 4 * i + dataArray[i]
                        );
                    }
                    avg /= bins;

                    // Animate the map bearing and light color over time, and make the light more
                    // intense when the audio is louder.
                    // map.setBearing(now / 500);
                    const hue = (now / 100) % 360;
                    const saturation = Math.min(50 + avg / 4, 100);
                    map.setLight({
                        color: `hsl(${hue},${saturation}%,50%)`,
                        intensity: Math.min(1, (avg / 256) * 10)
                    });

                    requestAnimationFrame(draw);
                }

                requestAnimationFrame(draw);
            })
            .catch((err) => {
                console.log('The following gUM error occurred:', err);
            });
    });
</script>

</body>
</html>
